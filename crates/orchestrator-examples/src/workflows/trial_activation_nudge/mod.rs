//! Trial Activation Nudge workflow:
//! Trigger -> HTTP fetch non-activated trials -> render nudge body -> send email.
//! On error from fetch/render/send, route to a child workflow that appends enriched error payloads to a local log file.

use std::path::{Path, PathBuf};
use std::sync::Arc;

use orchestrator_blocks::{
    Block, BlockRegistry, HttpRequestError, HttpRequester, SendEmail, SendEmailError,
    register_http_request, register_send_email,
};
use orchestrator_core::block::BlockError;
use orchestrator_core::{RunError, Workflow, WorkflowDefinition};

fn run_error(msg: impl Into<String>) -> RunError {
    RunError::Block(BlockError::Other(msg.into()))
}

fn write_if_missing(path: &Path, contents: &str) -> Result<(), std::io::Error> {
    if let Some(parent) = path.parent().filter(|p| !p.as_os_str().is_empty()) {
        std::fs::create_dir_all(parent)?;
    }
    if !path.exists() {
        std::fs::write(path, contents)?;
    }
    Ok(())
}

/// Ensure starter files for this workflow under `base_path`.
pub fn ensure_dummy_data(base_path: &Path) -> Result<(), std::io::Error> {
    std::fs::create_dir_all(base_path)?;
    write_if_missing(
        &base_path.join("trials_not_activated.json"),
        r#"{
  "items": [
    { "email": "alice@acme.com", "company": "Acme", "trial_started_at": "2026-02-05T10:00:00Z", "days_in_trial": 3 },
    { "email": "bob@northwind.com", "company": "Northwind", "trial_started_at": "2026-02-03T09:15:00Z", "days_in_trial": 5 }
  ]
}"#,
    )?;
    write_if_missing(
        &base_path.join("nudge_template.hbs"),
        r#"Trial Activation Nudge

The following trial accounts look inactive and need a follow-up:

{{{this}}}
"#,
    )?;
    write_if_missing(
        &base_path.join("error_template.hbs"),
        "{\"event\":\"trial_activation_nudge_error\",\"payload\":{{{this}}}}\n",
    )?;
    write_if_missing(
        &base_path.join("email_preview.html"),
        "<!-- generated by trial_activation_nudge workflow -->\n",
    )?;
    write_if_missing(&base_path.join("error_log.jsonl"), "")?;
    Ok(())
}

pub struct TrialActivationNudgeWorkflowConfig<'a> {
    pub endpoint_url: &'a str,
    pub to_email: &'a str,
    pub subject: &'a str,
    pub cron_expr: &'a str,
    pub use_cron: bool,
    pub nudge_template_path: &'a Path,
    pub error_template_path: &'a Path,
    pub trials_payload_path: &'a Path,
    pub email_out_path: &'a Path,
    pub error_log_path: &'a Path,
}

struct FilePayloadRequester {
    payload_path: PathBuf,
}

impl HttpRequester for FilePayloadRequester {
    fn get(
        &self,
        _url: &str,
        _timeout: std::time::Duration,
        _user_agent: Option<&str>,
    ) -> Result<String, HttpRequestError> {
        std::fs::read_to_string(&self.payload_path).map_err(|e| {
            HttpRequestError(format!(
                "read trial payload {}: {}",
                self.payload_path.display(),
                e
            ))
        })
    }
}

struct FilePreviewMailer {
    output_path: PathBuf,
}

impl SendEmail for FilePreviewMailer {
    fn send_email(
        &self,
        subject: &str,
        to_name: &str,
        to_email: &str,
        body: String,
    ) -> Result<(), SendEmailError> {
        let rendered = format!(
            "<!doctype html><html><body><h2>{}</h2><p>to: {} ({})</p><pre>{}</pre></body></html>\n",
            subject, to_email, to_name, body
        );
        std::fs::write(&self.output_path, rendered).map_err(|e| {
            SendEmailError(format!(
                "write email preview {}: {}",
                self.output_path.display(),
                e
            ))
        })
    }
}

fn build_registry(trials_payload_path: &Path, email_out_path: &Path) -> BlockRegistry {
    let mut registry = orchestrator_blocks::default_registry();
    register_http_request(
        &mut registry,
        Arc::new(FilePayloadRequester {
            payload_path: trials_payload_path.to_path_buf(),
        }),
    );
    register_send_email(
        &mut registry,
        Arc::new(FilePreviewMailer {
            output_path: email_out_path.to_path_buf(),
        }),
    );
    registry
}

fn build_error_handler_definition(
    error_template_path: &Path,
    error_log_path: &Path,
) -> Result<WorkflowDefinition, RunError> {
    let template = std::fs::read_to_string(error_template_path).map_err(|e| {
        run_error(format!(
            "read error template {}: {}",
            error_template_path.display(),
            e
        ))
    })?;
    let mut child = Workflow::with_registry(orchestrator_blocks::default_registry());
    let render = Block::template_handlebars(Some(template), None);
    let write = Block::file_write_append(Some(error_log_path.to_string_lossy().as_ref()));
    child.link(&render, &write);
    Ok(child.into_definition())
}

pub fn run_trial_activation_nudge_workflow(
    cfg: TrialActivationNudgeWorkflowConfig<'_>,
) -> Result<(), RunError> {
    let nudge_template = std::fs::read_to_string(cfg.nudge_template_path).map_err(|e| {
        run_error(format!(
            "read nudge template {}: {}",
            cfg.nudge_template_path.display(),
            e
        ))
    })?;
    let error_handler_def =
        build_error_handler_definition(cfg.error_template_path, cfg.error_log_path)?;

    let registry = build_registry(cfg.trials_payload_path, cfg.email_out_path);
    let mut w = Workflow::with_registry(registry);

    let trigger = if cfg.use_cron {
        Block::cron(cfg.cron_expr)
    } else {
        Block::custom_transform(None::<String>)
    };
    let fetch = Block::http_request(Some(cfg.endpoint_url))
        .set_timeout_ms(30_000)
        .set_retry_exponential(2, 1_000, 2.0);
    let render = Block::template_handlebars(Some(nudge_template), None);
    let send = Block::send_email(cfg.to_email, Some(cfg.subject))
        .set_timeout_ms(30_000)
        .set_retry_exponential(3, 1_000, 2.0);
    let on_error_handler = Block::child_workflow(error_handler_def);

    w.link(&trigger, &fetch);
    w.link(&fetch, &render);
    w.link(&render, &send);

    w.on_error(&fetch, &on_error_handler);
    w.on_error(&render, &on_error_handler);
    w.on_error(&send, &on_error_handler);

    let _ = w.run()?;
    Ok(())
}

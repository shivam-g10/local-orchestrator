//! AI news digest workflow:
//! Cron -> read feed URLs file -> split -> parallel HTTP fetch + RSS parse -> combine
//! -> custom news dedupe -> AI markdown digest -> HTML email render/send.
//! Uses child workflows for audit/state append logs.

mod blocks;

use std::path::Path;
use std::sync::Arc;

use orchestrator_blocks::{
    AiGenerator, Block, BlockRegistry, HttpRequester, RssParser, SendEmail, register_ai_generate,
    register_http_request, register_rss_parse, register_send_email,
};
use orchestrator_core::block::BlockError;
use orchestrator_core::{RunError, Workflow, WorkflowDefinition};

use blocks::{NewsDedupeBlock, NewsDedupeConfig};

fn run_error(msg: impl Into<String>) -> RunError {
    RunError::Block(BlockError::Other(msg.into()))
}

fn load_dotenv_for_example() {
    if let Ok(canon) = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join(".env")
        .canonicalize()
    {
        let _ = dotenvy::from_path(canon);
    }
    let _ = dotenvy::dotenv();
}

#[derive(Default)]
struct RegistryDeps {
    mailer: Option<Arc<dyn SendEmail>>,
    ai_generator: Option<Arc<dyn AiGenerator>>,
    http_requester: Option<Arc<dyn HttpRequester>>,
    rss_parser: Option<Arc<dyn RssParser>>,
}

/// Ensure dummy files for the ai_news_digest workflow under `base_path`.
pub fn ensure_dummy_data(base_path: &Path) -> Result<(), std::io::Error> {
    std::fs::create_dir_all(base_path)?;
    std::fs::create_dir_all(base_path.join("templates"))?;
    std::fs::create_dir_all(base_path.join("state"))?;
    std::fs::create_dir_all(base_path.join("logs"))?;

    std::fs::write(
        base_path.join("feeds.txt"),
        "https://hnrss.org/frontpage\nhttps://www.reddit.com/r/rust/.rss\n",
    )?;
    std::fs::write(
        base_path.join("prompt.md"),
        "You are preparing an inshorts-style digest.\nFor each item, write 2-3 concise bullets.\nReturn markdown only.\n",
    )?;
    std::fs::write(
        base_path.join("email_template.hbs"),
        r##"<!DOCTYPE html>
<html>
<body bgcolor="#f3f4f6" style="margin:0; padding:0; background-color:#f3f4f6;">
  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" bgcolor="#f3f4f6" style="border-collapse:collapse;">
    <tr>
      <td align="center" style="padding:20px 10px;">
        <table role="presentation" width="720" cellspacing="0" cellpadding="0" border="0" bgcolor="#ffffff" style="width:100%; max-width:720px; border-collapse:collapse; border:1px solid #e5e7eb;">
          <tr>
            <td bgcolor="#111827" style="padding:20px 24px; font-family:Arial, Helvetica, sans-serif;">
              <div style="display:inline-block; border:1px solid #9ca3af; color:#e5e7eb; font-size:11px; letter-spacing:1px; text-transform:uppercase; padding:3px 10px; margin-bottom:10px;">Daily Briefing</div>
              <h1 style="margin:0 0 8px 0; color:#f9fafb; font-size:42px; line-height:1.15; font-weight:700;">AI Inshorts Digest</h1>
              <p style="margin:0; color:#d1d5db; font-size:16px; line-height:24px;">Fast, high-signal updates from your curated sources.</p>
            </td>
          </tr>
          <tr>
            <td style="padding:20px 24px 24px 24px; font-family:Arial, Helvetica, sans-serif; color:#111827;">
              <p style="margin:0 0 14px 0; font-size:16px; line-height:24px;">Here is your latest digest:</p>
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" style="border-collapse:collapse; margin-bottom:16px;">
                <tr>
                  <td style="border-top:1px solid #e5e7eb; font-size:0; line-height:0;">&nbsp;</td>
                </tr>
              </table>
              <div style="font-size:16px; line-height:24px; color:#111827;">
                {{{body}}}
              </div>
              <p style="margin:18px 0 0 0; color:#6b7280; font-size:12px; line-height:18px;">Generated by local-orchestration workflow.</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
"##,
    )?;

    std::fs::write(
        base_path.join("templates").join("merged.hbs"),
        "==== merged_feeds ====\n{{{this}}}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("dedupe.hbs"),
        "{\"event\":\"dedupe\",\"new_count\":{{new_count}},\"total_count\":{{total_count}},\"skipped_count\":{{skipped_count}}}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("ai_markdown.hbs"),
        "==== ai_markdown ====\n{{{this}}}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("email_html.hbs"),
        "==== email_html ====\n{{{this}}}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("send.hbs"),
        "{\"event\":\"send\",\"sent\":{{sent}},\"to\":\"{{to}}\"}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("error.hbs"),
        "{\"event\":\"error\",\"message\":\"{{this}}\"}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("run_skip.hbs"),
        "{\"kind\":\"skip\",\"message\":\"{{this}}\"}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("run_error.hbs"),
        "{\"kind\":\"error\",\"message\":\"{{this}}\"}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("run_success.hbs"),
        "{\"kind\":\"success\",\"ts\":\"{{run_ts}}\",\"new_count\":{{dedupe.new_count}},\"sent\":{{send.sent}}}\n",
    )?;
    std::fs::write(
        base_path.join("templates").join("sent_items.hbs"),
        "{{#if send.sent}}\n{{#each dedupe.new_ids}}{\"id\":\"{{this}}\",\"sent_at\":\"{{../run_ts}}\"}\n{{/each}}{{/if}}",
    )?;
    Ok(())
}

fn build_registry(deps: &RegistryDeps, sent_items_path: &Path, max_items: usize) -> BlockRegistry {
    let mut r = orchestrator_blocks::default_registry();
    if let Some(mailer) = deps.mailer.as_ref() {
        register_send_email(&mut r, Arc::clone(mailer));
    }
    if let Some(ai) = deps.ai_generator.as_ref() {
        register_ai_generate(&mut r, Arc::clone(ai));
    }
    if let Some(http) = deps.http_requester.as_ref() {
        register_http_request(&mut r, Arc::clone(http));
    }
    if let Some(parser) = deps.rss_parser.as_ref() {
        register_rss_parse(&mut r, Arc::clone(parser));
    }
    let sent_path = sent_items_path.to_string_lossy().to_string();
    r.register_custom("news_dedupe", move |_| {
        Ok(Box::new(NewsDedupeBlock::new(NewsDedupeConfig {
            sent_items_path: sent_path.clone(),
            max_items,
        })))
    });
    r
}

fn read_urls(feeds_file: &Path) -> Result<Vec<String>, RunError> {
    let raw = std::fs::read_to_string(feeds_file)
        .map_err(|e| run_error(format!("read feeds file {}: {}", feeds_file.display(), e)))?;
    Ok(raw
        .lines()
        .map(str::trim)
        .filter(|l| !l.is_empty())
        .map(String::from)
        .collect())
}

fn build_log_child_definition(
    template_path: &Path,
    out_path: &Path,
) -> Result<WorkflowDefinition, RunError> {
    let template = std::fs::read_to_string(template_path).map_err(|e| {
        run_error(format!(
            "read log template {}: {}",
            template_path.display(),
            e
        ))
    })?;
    let mut w = Workflow::with_registry(orchestrator_blocks::default_registry());
    let render_id = w.add(Block::template_handlebars(Some(template), None));
    let write_id = w.add(Block::file_write_append(Some(
        out_path.to_string_lossy().as_ref(),
    )));
    w.link(render_id, write_id);
    Ok(w.into_definition())
}

fn add_audit_link(
    w: &mut Workflow,
    from: orchestrator_core::BlockId,
    template_path: &Path,
    out_path: &Path,
) -> Result<(), RunError> {
    let child = build_log_child_definition(template_path, out_path)?;
    let child_id = w.add(Block::child_workflow(child));
    w.link(from, child_id);
    Ok(())
}

fn add_error_link(
    w: &mut Workflow,
    from: orchestrator_core::BlockId,
    template_path: &Path,
    out_path: &Path,
) -> Result<(), RunError> {
    let child = build_log_child_definition(template_path, out_path)?;
    let child_id = w.add(Block::child_workflow(child));
    w.link_on_error(from, child_id);
    Ok(())
}

fn run_with_deps(
    deps: RegistryDeps,
    feeds_file: &Path,
    prompt_file: &Path,
    email_template_path: &Path,
    template_dir: &Path,
    state_dir: &Path,
    logs_dir: &Path,
    cron_expr: &str,
    to_email: &str,
    subject: &str,
    model: &str,
    api_key_env: Option<&str>,
    max_items: usize,
    use_cron: bool,
) -> Result<(), RunError> {
    let prompt = std::fs::read_to_string(prompt_file)
        .map_err(|e| run_error(format!("read prompt file {}: {}", prompt_file.display(), e)))?;
    let urls = read_urls(feeds_file)?;
    if urls.is_empty() {
        return Err(run_error("feeds file has no URLs"));
    }

    let sent_items_path = state_dir.join("sent_items.jsonl");
    let runs_path = state_dir.join("runs.jsonl");
    let registry = build_registry(&deps, &sent_items_path, max_items);
    let mut w = Workflow::with_registry(registry);

    let trigger_id = if use_cron {
        w.add(Block::cron(cron_expr))
    } else {
        w.add(Block::custom_transform(None::<String>))
    };
    let read_feeds_id = w.add(Block::file_read_force_config(Some(
        feeds_file.to_string_lossy().as_ref(),
    )));
    let split_id = w.add(Block::split_lines());
    w.link(trigger_id, read_feeds_id);
    w.link(read_feeds_id, split_id);

    let mut parsed_ids = Vec::new();
    for url in &urls {
        let http_id = w.add(Block::http_request(Some(url.as_str())));
        let parse_id = w.add(Block::rss_parse());
        w.link(split_id, http_id);
        w.link(http_id, parse_id);
        parsed_ids.push(parse_id);

        add_error_link(
            &mut w,
            http_id,
            &template_dir.join("error.hbs"),
            &logs_dir.join("errors.log"),
        )?;
        add_error_link(
            &mut w,
            http_id,
            &template_dir.join("run_error.hbs"),
            &runs_path,
        )?;
        add_error_link(
            &mut w,
            parse_id,
            &template_dir.join("error.hbs"),
            &logs_dir.join("errors.log"),
        )?;
        add_error_link(
            &mut w,
            parse_id,
            &template_dir.join("run_error.hbs"),
            &runs_path,
        )?;
    }

    let combine_keys: Vec<String> = (0..parsed_ids.len())
        .map(|i| format!("feed_{}", i))
        .collect();
    let merge_id = w.add(Block::combine(combine_keys));
    for id in &parsed_ids {
        w.link(*id, merge_id);
    }
    add_audit_link(
        &mut w,
        merge_id,
        &template_dir.join("merged.hbs"),
        &logs_dir.join("merged.log"),
    )?;

    let dedupe_id = w
        .add_custom("news_dedupe", serde_json::json!({}))
        .map_err(|e| run_error(e.to_string()))?;
    w.link(merge_id, dedupe_id);
    add_audit_link(
        &mut w,
        dedupe_id,
        &template_dir.join("dedupe.hbs"),
        &logs_dir.join("dedupe.log"),
    )?;
    add_error_link(
        &mut w,
        dedupe_id,
        &template_dir.join("run_skip.hbs"),
        &runs_path,
    )?;
    add_error_link(
        &mut w,
        dedupe_id,
        &template_dir.join("error.hbs"),
        &logs_dir.join("errors.log"),
    )?;

    let ai_id = w.add(Block::ai_generate(
        prompt,
        Some("openai"),
        Some(model),
        Some(api_key_env.unwrap_or("OPENAI_API_KEY")),
    ));
    w.link(dedupe_id, ai_id);
    add_audit_link(
        &mut w,
        ai_id,
        &template_dir.join("ai_markdown.hbs"),
        &logs_dir.join("ai_markdown.log"),
    )?;
    add_error_link(
        &mut w,
        ai_id,
        &template_dir.join("error.hbs"),
        &logs_dir.join("errors.log"),
    )?;
    add_error_link(
        &mut w,
        ai_id,
        &template_dir.join("run_error.hbs"),
        &runs_path,
    )?;

    let markdown_id = w.add(Block::markdown_to_html());
    w.link(ai_id, markdown_id);

    let read_email_template_id = w.add(Block::file_read_force_config(Some(
        email_template_path.to_string_lossy().as_ref(),
    )));
    // Link from Json-producing block to avoid overriding file_read path from string input.
    w.link(dedupe_id, read_email_template_id);
    add_error_link(
        &mut w,
        read_email_template_id,
        &template_dir.join("error.hbs"),
        &logs_dir.join("errors.log"),
    )?;

    let combine_email_id = w.add(Block::combine(vec![
        "body".to_string(),
        "template".to_string(),
    ]));
    w.link(markdown_id, combine_email_id);
    w.link(read_email_template_id, combine_email_id);

    let render_email_id = w.add(Block::template_handlebars(None::<String>, None));
    w.link(combine_email_id, render_email_id);
    add_audit_link(
        &mut w,
        render_email_id,
        &template_dir.join("email_html.hbs"),
        &logs_dir.join("email_html.log"),
    )?;
    add_error_link(
        &mut w,
        render_email_id,
        &template_dir.join("error.hbs"),
        &logs_dir.join("errors.log"),
    )?;

    let send_id = w.add(Block::send_email(to_email, Some(subject)));
    w.link(render_email_id, send_id);
    add_audit_link(
        &mut w,
        send_id,
        &template_dir.join("send.hbs"),
        &logs_dir.join("send.log"),
    )?;
    add_error_link(
        &mut w,
        send_id,
        &template_dir.join("error.hbs"),
        &logs_dir.join("errors.log"),
    )?;
    add_error_link(
        &mut w,
        send_id,
        &template_dir.join("run_error.hbs"),
        &runs_path,
    )?;

    let combine_post_send_id = w.add(Block::combine(vec![
        "dedupe".to_string(),
        "send".to_string(),
        "run_ts".to_string(),
    ]));
    w.link(dedupe_id, combine_post_send_id);
    w.link(send_id, combine_post_send_id);
    w.link(trigger_id, combine_post_send_id);

    add_audit_link(
        &mut w,
        combine_post_send_id,
        &template_dir.join("sent_items.hbs"),
        &sent_items_path,
    )?;
    add_audit_link(
        &mut w,
        combine_post_send_id,
        &template_dir.join("run_success.hbs"),
        &runs_path,
    )?;

    w.run()?;
    Ok(())
}

/// Run ai_news_digest workflow with built-in default registry implementations.
pub fn run_ai_news_digest_workflow(
    feeds_file: &Path,
    prompt_file: &Path,
    email_template_path: &Path,
    template_dir: &Path,
    state_dir: &Path,
    logs_dir: &Path,
    cron_expr: &str,
    to_email: &str,
    subject: &str,
    model: &str,
    api_key_env: Option<&str>,
    max_items: usize,
) -> Result<(), RunError> {
    load_dotenv_for_example();
    run_with_deps(
        RegistryDeps::default(),
        feeds_file,
        prompt_file,
        email_template_path,
        template_dir,
        state_dir,
        logs_dir,
        cron_expr,
        to_email,
        subject,
        model,
        api_key_env,
        max_items,
        true,
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use std::time::Duration;

    struct FakeRequester;
    impl HttpRequester for FakeRequester {
        fn get(
            &self,
            _url: &str,
            _timeout: Duration,
            _user_agent: Option<&str>,
        ) -> Result<String, orchestrator_blocks::HttpRequestError> {
            Ok(
                r#"<?xml version="1.0"?><rss version="2.0"><channel><title>X</title><item><title>T1</title><link>https://example.com/1</link><guid>g1</guid><description>S1</description></item></channel></rss>"#
                    .to_string(),
            )
        }
    }

    struct FakeAi;
    impl AiGenerator for FakeAi {
        fn generate_markdown(
            &self,
            _config: &orchestrator_blocks::AiGenerateConfig,
            input: &serde_json::Value,
        ) -> Result<String, orchestrator_blocks::AiGenerateError> {
            let count = input
                .get("new_items")
                .and_then(|v| v.as_array())
                .map(std::vec::Vec::len)
                .unwrap_or(0);
            Ok(format!("# Digest\n- items: {}", count))
        }
    }

    struct TestMailer {
        output_path: PathBuf,
    }

    impl SendEmail for TestMailer {
        fn send_email(
            &self,
            subject: &str,
            _to_name: &str,
            to_email: &str,
            body: String,
        ) -> Result<(), orchestrator_blocks::SendEmailError> {
            let payload = format!("To: {}\nSubject: {}\n\n{}", to_email, subject, body);
            std::fs::write(&self.output_path, payload)
                .map_err(|e| orchestrator_blocks::SendEmailError(e.to_string()))?;
            Ok(())
        }
    }

    #[test]
    fn ai_news_digest_template_is_inline_email_friendly() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let tpl = std::fs::read_to_string(dir.path().join("email_template.hbs")).unwrap();
        assert!(tpl.contains("width=\"720\""));
        assert!(tpl.contains("font-family:Arial"));
        assert!(!tpl.contains("<style>"));
    }

    #[test]
    fn ai_news_digest_first_run_sends_second_run_skips() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let email_out = logs_dir.join("email_out.html");

        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let first = run_with_deps(
            deps,
            &feeds_file,
            &prompt_file,
            &email_template,
            &template_dir,
            &state_dir,
            &logs_dir,
            "* * * * * * *",
            "test@example.com",
            "Digest",
            "gpt-5-nano",
            Some("NO_KEY_NEEDED"),
            10,
            false,
        );
        assert!(first.is_ok(), "first run failed: {:?}", first.err());
        assert!(email_out.exists());

        let deps2 = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };
        let second = run_with_deps(
            deps2,
            &feeds_file,
            &prompt_file,
            &email_template,
            &template_dir,
            &state_dir,
            &logs_dir,
            "* * * * * * *",
            "test@example.com",
            "Digest",
            "gpt-5-nano",
            Some("NO_KEY_NEEDED"),
            10,
            false,
        );
        assert!(
            second.is_err(),
            "second run should fail on no_new_items path"
        );
        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(runs.contains("\"kind\":\"skip\""), "runs log: {}", runs);
    }

    #[test]
    fn ai_news_digest_single_feed_still_sends() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        std::fs::write(&feeds_file, "https://hnrss.org/frontpage\n").unwrap();

        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let email_out = logs_dir.join("email_out.html");

        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let run = run_with_deps(
            deps,
            &feeds_file,
            &prompt_file,
            &email_template,
            &template_dir,
            &state_dir,
            &logs_dir,
            "* * * * * * *",
            "test@example.com",
            "Digest",
            "gpt-5-nano",
            Some("NO_KEY_NEEDED"),
            10,
            false,
        );
        assert!(run.is_ok(), "single-feed run failed: {:?}", run.err());

        assert!(email_out.exists());
        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(runs.contains("\"kind\":\"success\""), "runs log: {}", runs);
    }

    #[test]
    fn ai_news_digest_missing_api_key_logs_error_and_fails() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        std::fs::write(&feeds_file, "https://hnrss.org/frontpage\n").unwrap();

        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: logs_dir.join("email_out.html"),
            })),
            ai_generator: None,
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let run = run_with_deps(
            deps,
            &feeds_file,
            &prompt_file,
            &email_template,
            &template_dir,
            &state_dir,
            &logs_dir,
            "* * * * * * *",
            "test@example.com",
            "Digest",
            "gpt-5-nano",
            Some("INTENTIONALLY_MISSING_AI_KEY"),
            10,
            false,
        );
        assert!(run.is_err(), "run should fail when API key is missing");

        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(
            runs.contains("\"kind\":\"error\""),
            "expected error run log, got: {}",
            runs
        );

        let errors = std::fs::read_to_string(logs_dir.join("errors.log")).unwrap();
        assert!(
            errors.contains("missing API key env var"),
            "expected ai key error log, got: {}",
            errors
        );
    }
}

//! AI news digest workflow:
//! Cron -> read feed URLs file -> split -> parallel HTTP fetch + RSS parse -> combine
//! -> custom news dedupe -> AI markdown digest -> HTML email render/send.
//! Uses child workflows for audit/state append logs.

mod blocks;

use std::path::Path;
use std::sync::Arc;

use orchestrator_blocks::{
    AiGenerator, Block, BlockRegistry, HttpRequester, RssParser, SendEmail, register_ai_generate,
    register_http_request, register_rss_parse, register_send_email,
};
use orchestrator_core::block::BlockError;
use orchestrator_core::{RunError, Workflow, WorkflowDefinition};

use blocks::{NewsDedupeBlock, NewsDedupeConfig};

fn run_error(msg: impl Into<String>) -> RunError {
    RunError::Block(BlockError::Other(msg.into()))
}

fn is_no_new_items_error(err: &RunError) -> bool {
    match err {
        RunError::Block(BlockError::Other(message)) => {
            serde_json::from_str::<serde_json::Value>(message)
                .ok()
                .and_then(|v| {
                    v.get("kind")
                        .and_then(|k| k.as_str())
                        .map(|k| k == "no_new_items")
                })
                .unwrap_or(false)
        }
        _ => false,
    }
}

fn load_dotenv_for_example() {
    if let Ok(canon) = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join(".env")
        .canonicalize()
    {
        let _ = dotenvy::from_path(canon);
    }
    let _ = dotenvy::dotenv();
}

#[derive(Default)]
struct RegistryDeps {
    mailer: Option<Arc<dyn SendEmail>>,
    ai_generator: Option<Arc<dyn AiGenerator>>,
    http_requester: Option<Arc<dyn HttpRequester>>,
    rss_parser: Option<Arc<dyn RssParser>>,
}

/// Ensure dummy files for the ai_news_digest workflow under `base_path`.
fn write_if_missing(path: &Path, contents: &str) -> Result<(), std::io::Error> {
    if !path.exists() {
        std::fs::write(path, contents)?;
    }
    Ok(())
}

/// Ensure dummy files for the ai_news_digest workflow under `base_path`.
pub fn ensure_dummy_data(base_path: &Path) -> Result<(), std::io::Error> {
    std::fs::create_dir_all(base_path)?;
    std::fs::create_dir_all(base_path.join("templates"))?;
    std::fs::create_dir_all(base_path.join("state"))?;
    std::fs::create_dir_all(base_path.join("logs"))?;

    let default_feeds = concat!(
        "https://www.hindustantimes.com/feeds/rss/india-news/rssfeed.xml\n",
        "https://indianexpress.com/section/india/feed/\n",
        "https://timesofindia.indiatimes.com/rssfeeds/-2128936835.cms\n",
        "https://www.thehindu.com/news/national/feeder/default.rss\n",
        "https://www.news18.com/rss/india.xml\n",
        "https://www.firstpost.com/commonfeeds/v1/mfp/rss/india.xml\n",
    );
    write_if_missing(&base_path.join("feeds.txt"), default_feeds)?;
    write_if_missing(
        &base_path.join("prompt.md"),
        "You are preparing an inshorts-style digest.\nFor each item, write 2-3 concise bullets.\nReturn markdown only.\n",
    )?;
    write_if_missing(
        &base_path.join("email_template.hbs"),
        r##"<!DOCTYPE html>
<html>
<body bgcolor="#f3f4f6" style="margin:0; padding:0; background-color:#f3f4f6;">
  <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" bgcolor="#f3f4f6" style="border-collapse:collapse;">
    <tr>
      <td align="center" style="padding:20px 10px;">
        <table role="presentation" width="720" cellspacing="0" cellpadding="0" border="0" bgcolor="#ffffff" style="width:100%; max-width:720px; border-collapse:collapse; border:1px solid #e5e7eb;">
          <tr>
            <td bgcolor="#111827" style="padding:20px 24px; font-family:Arial, Helvetica, sans-serif;">
              <div style="display:inline-block; border:1px solid #9ca3af; color:#e5e7eb; font-size:11px; letter-spacing:1px; text-transform:uppercase; padding:3px 10px; margin-bottom:10px;">Daily Briefing</div>
              <h1 style="margin:0 0 8px 0; color:#f9fafb; font-size:42px; line-height:1.15; font-weight:700;">AI Inshorts Digest</h1>
              <p style="margin:0; color:#d1d5db; font-size:16px; line-height:24px;">Fast, high-signal updates from your curated sources.</p>
            </td>
          </tr>
          <tr>
            <td style="padding:20px 24px 24px 24px; font-family:Arial, Helvetica, sans-serif; color:#111827;">
              <p style="margin:0 0 14px 0; font-size:16px; line-height:24px;">Here is your latest digest:</p>
              <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" style="border-collapse:collapse; margin-bottom:16px;">
                <tr>
                  <td style="border-top:1px solid #e5e7eb; font-size:0; line-height:0;">&nbsp;</td>
                </tr>
              </table>
              <div style="font-size:16px; line-height:24px; color:#111827;">
                {{{body}}}
              </div>
              <p style="margin:18px 0 0 0; color:#6b7280; font-size:12px; line-height:18px;">Generated by local-orchestration workflow.</p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
"##,
    )?;

    write_if_missing(
        &base_path.join("templates").join("merged.hbs"),
        "==== merged_feeds ====\n{{{this}}}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("dedupe.hbs"),
        "{\"event\":\"dedupe\",\"new_count\":{{new_count}},\"total_count\":{{total_count}},\"skipped_count\":{{skipped_count}}}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("ai_markdown.hbs"),
        "==== ai_markdown ====\n{{{this}}}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("email_html.hbs"),
        "==== email_html ====\n{{{this}}}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("send.hbs"),
        "{\"event\":\"send\",\"sent\":{{sent}},\"to\":\"{{to}}\"}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("error.hbs"),
        "{\"event\":\"error\",\"message\":\"{{this}}\"}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("run_skip.hbs"),
        "{\"kind\":\"skip\",\"message\":\"{{this}}\"}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("run_error.hbs"),
        "{\"kind\":\"error\",\"message\":\"{{this}}\"}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("run_success.hbs"),
        "{\"kind\":\"success\",\"ts\":\"{{run_ts}}\",\"new_count\":{{dedupe.new_count}},\"sent\":{{send.sent}}}\n",
    )?;
    write_if_missing(
        &base_path.join("templates").join("sent_items.hbs"),
        "{{#if send.sent}}\n{{#each dedupe.new_ids}}{\"id\":\"{{this}}\",\"sent_at\":\"{{../run_ts}}\"}\n{{/each}}{{/if}}",
    )?;
    Ok(())
}

fn build_registry(deps: &RegistryDeps, sent_items_path: &Path, max_items: usize) -> BlockRegistry {
    let mut r = orchestrator_blocks::default_registry();
    if let Some(mailer) = deps.mailer.as_ref() {
        register_send_email(&mut r, Arc::clone(mailer));
    }
    if let Some(ai) = deps.ai_generator.as_ref() {
        register_ai_generate(&mut r, Arc::clone(ai));
    }
    if let Some(http) = deps.http_requester.as_ref() {
        register_http_request(&mut r, Arc::clone(http));
    }
    if let Some(parser) = deps.rss_parser.as_ref() {
        register_rss_parse(&mut r, Arc::clone(parser));
    }
    let sent_path = sent_items_path.to_string_lossy().to_string();
    r.register_custom("news_dedupe", move |_, _input_from| {
        Ok(Box::new(NewsDedupeBlock::new(NewsDedupeConfig {
            sent_items_path: sent_path.clone(),
            max_items,
        })))
    });
    r
}

fn read_urls(feeds_file: &Path) -> Result<Vec<String>, RunError> {
    let raw = std::fs::read_to_string(feeds_file)
        .map_err(|e| run_error(format!("read feeds file {}: {}", feeds_file.display(), e)))?;
    Ok(raw
        .lines()
        .map(str::trim)
        .filter(|l| !l.is_empty())
        .map(String::from)
        .collect())
}

fn build_log_child_definition(
    template_path: &Path,
    out_path: &Path,
) -> Result<WorkflowDefinition, RunError> {
    let template = std::fs::read_to_string(template_path).map_err(|e| {
        run_error(format!(
            "read log template {}: {}",
            template_path.display(),
            e
        ))
    })?;
    let mut w = Workflow::with_registry(orchestrator_blocks::default_registry());
    let render = Block::template_handlebars(Some(template), None);
    let write = Block::file_write_append(Some(out_path.to_string_lossy().as_ref()));
    w.link(&render, &write);
    Ok(w.into_definition())
}

fn add_audit_link(
    w: &mut Workflow,
    from: &Block,
    template_path: &Path,
    out_path: &Path,
) -> Result<(), RunError> {
    let child = build_log_child_definition(template_path, out_path)?;
    let child_block = Block::child_workflow(child);
    w.link(from, child_block);
    Ok(())
}

fn add_error_link(
    w: &mut Workflow,
    from: &Block,
    template_path: &Path,
    out_path: &Path,
) -> Result<(), RunError> {
    let child = build_log_child_definition(template_path, out_path)?;
    let child_block = Block::child_workflow(child);
    w.link_on_error(from, child_block);
    Ok(())
}

struct RunWithDepsConfig<'a> {
    feeds_file: &'a Path,
    prompt_file: &'a Path,
    email_template_path: &'a Path,
    template_dir: &'a Path,
    state_dir: &'a Path,
    logs_dir: &'a Path,
    cron_expr: &'a str,
    to_email: &'a str,
    subject: &'a str,
    model: &'a str,
    api_key_env: Option<&'a str>,
    max_items: usize,
    use_cron: bool,
}

pub struct AiNewsDigestWorkflowConfig<'a> {
    pub feeds_file: &'a Path,
    pub prompt_file: &'a Path,
    pub email_template_path: &'a Path,
    pub template_dir: &'a Path,
    pub state_dir: &'a Path,
    pub logs_dir: &'a Path,
    pub cron_expr: &'a str,
    pub to_email: &'a str,
    pub subject: &'a str,
    pub model: &'a str,
    pub api_key_env: Option<&'a str>,
    pub max_items: usize,
}

fn run_with_deps(deps: RegistryDeps, cfg: RunWithDepsConfig<'_>) -> Result<(), RunError> {
    let prompt = std::fs::read_to_string(cfg.prompt_file).map_err(|e| {
        run_error(format!(
            "read prompt file {}: {}",
            cfg.prompt_file.display(),
            e
        ))
    })?;
    let urls = read_urls(cfg.feeds_file)?;
    if urls.is_empty() {
        return Err(run_error("feeds file has no URLs"));
    }

    let sent_items_path = cfg.state_dir.join("sent_items.jsonl");
    let runs_path = cfg.state_dir.join("runs.jsonl");
    let registry = build_registry(&deps, &sent_items_path, cfg.max_items);
    let mut w = Workflow::with_registry(registry);

    let trigger = if cfg.use_cron {
        Block::cron(cfg.cron_expr)
    } else {
        Block::custom_transform(None::<String>)
    };
    let read_feeds = Block::file_read_force_config(Some(cfg.feeds_file.to_string_lossy().as_ref()));
    let split = Block::split_lines();
    let combine_keys: Vec<String> = (0..urls.len()).map(|i| format!("feed_{}", i)).collect();
    let merge = Block::combine(combine_keys);
    w.link(&trigger, &read_feeds);
    w.link(&read_feeds, &split);

    let mut _feed_blocks: Vec<(Box<Block>, Box<Block>)> = Vec::with_capacity(urls.len());
    for url in &urls {
        let http = Box::new(Block::http_request(Some(url.as_str())));
        let parse = Box::new(Block::rss_parse());
        w.link(&split, http.as_ref());
        w.link(http.as_ref(), parse.as_ref());
        w.link(parse.as_ref(), &merge);

        add_error_link(
            &mut w,
            http.as_ref(),
            &cfg.template_dir.join("error.hbs"),
            &cfg.logs_dir.join("errors.log"),
        )?;
        add_error_link(
            &mut w,
            http.as_ref(),
            &cfg.template_dir.join("run_error.hbs"),
            &runs_path,
        )?;
        add_error_link(
            &mut w,
            parse.as_ref(),
            &cfg.template_dir.join("error.hbs"),
            &cfg.logs_dir.join("errors.log"),
        )?;
        add_error_link(
            &mut w,
            parse.as_ref(),
            &cfg.template_dir.join("run_error.hbs"),
            &runs_path,
        )?;
        _feed_blocks.push((http, parse));
    }
    add_audit_link(
        &mut w,
        &merge,
        &cfg.template_dir.join("merged.hbs"),
        &cfg.logs_dir.join("merged.log"),
    )?;

    let dedupe = Block::custom("news_dedupe", serde_json::json!({}));
    w.link(&merge, &dedupe);
    add_audit_link(
        &mut w,
        &dedupe,
        &cfg.template_dir.join("dedupe.hbs"),
        &cfg.logs_dir.join("dedupe.log"),
    )?;
    add_error_link(
        &mut w,
        &dedupe,
        &cfg.template_dir.join("run_skip.hbs"),
        &runs_path,
    )?;
    add_error_link(
        &mut w,
        &dedupe,
        &cfg.template_dir.join("error.hbs"),
        &cfg.logs_dir.join("errors.log"),
    )?;

    let ai = Block::ai_generate(
        prompt,
        Some("openai"),
        Some(cfg.model),
        Some(cfg.api_key_env.unwrap_or("OPENAI_API_KEY")),
    );
    w.link(&dedupe, &ai);
    add_audit_link(
        &mut w,
        &ai,
        &cfg.template_dir.join("ai_markdown.hbs"),
        &cfg.logs_dir.join("ai_markdown.log"),
    )?;
    add_error_link(
        &mut w,
        &ai,
        &cfg.template_dir.join("error.hbs"),
        &cfg.logs_dir.join("errors.log"),
    )?;
    add_error_link(
        &mut w,
        &ai,
        &cfg.template_dir.join("run_error.hbs"),
        &runs_path,
    )?;

    let markdown = Block::markdown_to_html();
    w.link(&ai, &markdown);

    let read_email_template =
        Block::file_read_force_config(Some(cfg.email_template_path.to_string_lossy().as_ref()));
    // Link from Json-producing block to avoid overriding file_read path from string input.
    w.link(&dedupe, &read_email_template);
    add_error_link(
        &mut w,
        &read_email_template,
        &cfg.template_dir.join("error.hbs"),
        &cfg.logs_dir.join("errors.log"),
    )?;

    let combine_email = Block::combine(vec!["body".to_string(), "template".to_string()]);
    w.link(&markdown, &combine_email);
    w.link(&read_email_template, &combine_email);

    let render_email = Block::template_handlebars(None::<String>, None);
    w.link(&combine_email, &render_email);
    add_audit_link(
        &mut w,
        &render_email,
        &cfg.template_dir.join("email_html.hbs"),
        &cfg.logs_dir.join("email_html.log"),
    )?;
    add_error_link(
        &mut w,
        &render_email,
        &cfg.template_dir.join("error.hbs"),
        &cfg.logs_dir.join("errors.log"),
    )?;

    let send = Block::send_email(cfg.to_email, Some(cfg.subject));
    w.link(&render_email, &send);
    add_audit_link(
        &mut w,
        &send,
        &cfg.template_dir.join("send.hbs"),
        &cfg.logs_dir.join("send.log"),
    )?;
    add_error_link(
        &mut w,
        &send,
        &cfg.template_dir.join("error.hbs"),
        &cfg.logs_dir.join("errors.log"),
    )?;
    add_error_link(
        &mut w,
        &send,
        &cfg.template_dir.join("run_error.hbs"),
        &runs_path,
    )?;

    let combine_post_send = Block::combine(vec![
        "dedupe".to_string(),
        "send".to_string(),
        "run_ts".to_string(),
    ]);
    w.link(&dedupe, &combine_post_send);
    w.link(&send, &combine_post_send);
    w.link(&trigger, &combine_post_send);

    add_audit_link(
        &mut w,
        &combine_post_send,
        &cfg.template_dir.join("sent_items.hbs"),
        &sent_items_path,
    )?;
    add_audit_link(
        &mut w,
        &combine_post_send,
        &cfg.template_dir.join("run_success.hbs"),
        &runs_path,
    )?;

    match w.run() {
        Ok(_) => Ok(()),
        Err(err) if is_no_new_items_error(&err) => Ok(()),
        Err(err) => Err(err),
    }
}

/// Run ai_news_digest workflow with built-in default registry implementations.
pub fn run_ai_news_digest_workflow(cfg: AiNewsDigestWorkflowConfig<'_>) -> Result<(), RunError> {
    load_dotenv_for_example();
    run_with_deps(
        RegistryDeps::default(),
        RunWithDepsConfig {
            feeds_file: cfg.feeds_file,
            prompt_file: cfg.prompt_file,
            email_template_path: cfg.email_template_path,
            template_dir: cfg.template_dir,
            state_dir: cfg.state_dir,
            logs_dir: cfg.logs_dir,
            cron_expr: cfg.cron_expr,
            to_email: cfg.to_email,
            subject: cfg.subject,
            model: cfg.model,
            api_key_env: cfg.api_key_env,
            max_items: cfg.max_items,
            use_cron: true,
        },
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use std::time::Duration;

    struct FakeRequester;
    impl HttpRequester for FakeRequester {
        fn get(
            &self,
            _url: &str,
            _timeout: Duration,
            _user_agent: Option<&str>,
        ) -> Result<String, orchestrator_blocks::HttpRequestError> {
            Ok(
                r#"<?xml version="1.0"?><rss version="2.0"><channel><title>X</title><item><title>T1</title><link>https://example.com/1</link><guid>g1</guid><description>S1</description></item></channel></rss>"#
                    .to_string(),
            )
        }
    }

    struct FakeAi;
    impl AiGenerator for FakeAi {
        fn generate_markdown(
            &self,
            _config: &orchestrator_blocks::AiGenerateConfig,
            input: &serde_json::Value,
        ) -> Result<String, orchestrator_blocks::AiGenerateError> {
            let count = input
                .get("new_items")
                .and_then(|v| v.as_array())
                .map(std::vec::Vec::len)
                .unwrap_or(0);
            Ok(format!("# Digest\n- items: {}", count))
        }
    }

    struct TestMailer {
        output_path: PathBuf,
    }

    impl SendEmail for TestMailer {
        fn send_email(
            &self,
            subject: &str,
            _to_name: &str,
            to_email: &str,
            body: String,
        ) -> Result<(), orchestrator_blocks::SendEmailError> {
            let payload = format!("To: {}\nSubject: {}\n\n{}", to_email, subject, body);
            std::fs::write(&self.output_path, payload)
                .map_err(|e| orchestrator_blocks::SendEmailError(e.to_string()))?;
            Ok(())
        }
    }

    #[test]
    fn ai_news_digest_template_is_inline_email_friendly() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let tpl = std::fs::read_to_string(dir.path().join("email_template.hbs")).unwrap();
        assert!(tpl.contains("width=\"720\""));
        assert!(tpl.contains("font-family:Arial"));
        assert!(!tpl.contains("<style>"));
    }

    #[test]
    fn ai_news_digest_first_run_sends_second_run_skips() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let email_out = logs_dir.join("email_out.html");

        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let first = run_with_deps(
            deps,
            RunWithDepsConfig {
                feeds_file: &feeds_file,
                prompt_file: &prompt_file,
                email_template_path: &email_template,
                template_dir: &template_dir,
                state_dir: &state_dir,
                logs_dir: &logs_dir,
                cron_expr: "* * * * * * *",
                to_email: "test@example.com",
                subject: "Digest",
                model: "gpt-5-nano",
                api_key_env: Some("NO_KEY_NEEDED"),
                max_items: 10,
                use_cron: false,
            },
        );
        assert!(first.is_ok(), "first run failed: {:?}", first.err());
        assert!(email_out.exists());

        let deps2 = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };
        let second = run_with_deps(
            deps2,
            RunWithDepsConfig {
                feeds_file: &feeds_file,
                prompt_file: &prompt_file,
                email_template_path: &email_template,
                template_dir: &template_dir,
                state_dir: &state_dir,
                logs_dir: &logs_dir,
                cron_expr: "* * * * * * *",
                to_email: "test@example.com",
                subject: "Digest",
                model: "gpt-5-nano",
                api_key_env: Some("NO_KEY_NEEDED"),
                max_items: 10,
                use_cron: false,
            },
        );
        assert!(
            second.is_ok(),
            "second run should skip without returning error: {:?}",
            second.err()
        );
        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(runs.contains("\"kind\":\"skip\""), "runs log: {}", runs);
        let send = std::fs::read_to_string(logs_dir.join("send.log")).unwrap();
        let send_lines = send.lines().filter(|l| !l.trim().is_empty()).count();
        assert_eq!(send_lines, 1, "expected only first run to send email");
    }

    #[test]
    fn ai_news_digest_single_feed_still_sends() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        std::fs::write(&feeds_file, "https://hnrss.org/frontpage\n").unwrap();

        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let email_out = logs_dir.join("email_out.html");

        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: email_out.clone(),
            })),
            ai_generator: Some(Arc::new(FakeAi)),
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let run = run_with_deps(
            deps,
            RunWithDepsConfig {
                feeds_file: &feeds_file,
                prompt_file: &prompt_file,
                email_template_path: &email_template,
                template_dir: &template_dir,
                state_dir: &state_dir,
                logs_dir: &logs_dir,
                cron_expr: "* * * * * * *",
                to_email: "test@example.com",
                subject: "Digest",
                model: "gpt-5-nano",
                api_key_env: Some("NO_KEY_NEEDED"),
                max_items: 10,
                use_cron: false,
            },
        );
        assert!(run.is_ok(), "single-feed run failed: {:?}", run.err());

        assert!(email_out.exists());
        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(runs.contains("\"kind\":\"success\""), "runs log: {}", runs);
    }

    #[test]
    fn ai_news_digest_missing_api_key_logs_error_and_fails() {
        let dir = tempfile::tempdir().unwrap();
        ensure_dummy_data(dir.path()).unwrap();
        let feeds_file = dir.path().join("feeds.txt");
        std::fs::write(&feeds_file, "https://hnrss.org/frontpage\n").unwrap();

        let prompt_file = dir.path().join("prompt.md");
        let email_template = dir.path().join("email_template.hbs");
        let template_dir = dir.path().join("templates");
        let state_dir = dir.path().join("state");
        let logs_dir = dir.path().join("logs");
        let deps = RegistryDeps {
            mailer: Some(Arc::new(TestMailer {
                output_path: logs_dir.join("email_out.html"),
            })),
            ai_generator: None,
            http_requester: Some(Arc::new(FakeRequester)),
            rss_parser: None,
        };

        let run = run_with_deps(
            deps,
            RunWithDepsConfig {
                feeds_file: &feeds_file,
                prompt_file: &prompt_file,
                email_template_path: &email_template,
                template_dir: &template_dir,
                state_dir: &state_dir,
                logs_dir: &logs_dir,
                cron_expr: "* * * * * * *",
                to_email: "test@example.com",
                subject: "Digest",
                model: "gpt-5-nano",
                api_key_env: Some("INTENTIONALLY_MISSING_AI_KEY"),
                max_items: 10,
                use_cron: false,
            },
        );
        assert!(run.is_err(), "run should fail when API key is missing");

        let runs = std::fs::read_to_string(state_dir.join("runs.jsonl")).unwrap();
        assert!(
            runs.contains("\"kind\":\"error\""),
            "expected error run log, got: {}",
            runs
        );

        let errors = std::fs::read_to_string(logs_dir.join("errors.log")).unwrap();
        assert!(
            errors.contains("missing API key env var"),
            "expected ai key error log, got: {}",
            errors
        );
    }
}

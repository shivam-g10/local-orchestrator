# Block Simplicity v4.6 Plan

Status: Draft  
Date: February 14, 2026

## Summary

1. Keep user interaction strictly block-first: users compose and glue blocks; node/runtime mechanics are hidden.
2. Simplify block authoring to `#[derive(Block)]` plus exactly two required methods: `validate` and `run`.
3. Use one common value type for block IO: `BlockValue`.
4. Remove public `wf.add` usage from the primary API path.
5. Auto-wire input sources from `link`, auto-select entry from first linked source block, and auto-run validation inside `run`.
6. Remove `input_from_map`; use a standalone `map_input` block primitive.
7. Keep plugins and built-ins-as-plugins, with a binary ABI boundary (no JSON contract transport).

## Goals

1. Reduce block author cognitive load.
2. Eliminate ad-hoc payload key coupling between blocks.
3. Keep runtime behavior deterministic and validation-first.
4. Preserve extensibility while improving ergonomics.

## Non-Goals

1. Marketplace/distribution/sandbox policy changes.
2. Dynamic unknown-plugin composition ergonomics beyond current typed Rust model.
3. Persistence/export contract for closure-backed mapping in this slice.

## Decisions Locked

1. IO type is `BlockValue` (prefixed naming retained everywhere).
2. Map representation is `BTreeMap<String, BlockValue>` for deterministic ordering.
3. Contract validation is kind-level (`BlockValueKindSet`) by default.
4. Block author methods are only:
   - `validate(&self, input: &BlockValue, ctx: &BlockValidateContext) -> Result<(), BlockError>`
   - `run(&self, input: BlockValue, ctx: &BlockContext) -> Result<BlockRunResult, BlockError>` (sync or async).
5. Missing `validate` or `run` is a compile-time derive error.
6. Validation phase must never execute side effects.
7. `wf.add` is removed from primary public usage.
8. `link` sets input binding implicitly and deduplicates repeated source bindings.
9. Entry block is inferred from the first `link(from, to)` call (`from`).
10. `run` and `run_async` always validate first.
11. `input_from_map` is removed; mapping is modeled as standalone `map_input` block.

## Public API Changes

### 1) Core block model (`crates/orchestrator-core/src/block/mod.rs`)

Introduce:

```rust
pub enum BlockValue {
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
    Bytes(Vec<u8>),
    List(Vec<BlockValue>),
    Map(std::collections::BTreeMap<String, BlockValue>),
}

pub enum BlockRunResult {
    Once(BlockValue),
    Multiple(Vec<BlockValue>),
    Recurring(BlockStream<BlockValue>),
}
```

Introduce contracts:

```rust
pub enum BlockValueKind { Null, Bool, Int, Float, String, Bytes, List, Map }
pub struct BlockValueKindSet(/* bitset */);
pub struct BlockValueContract { pub mode: OutputMode, pub kinds: BlockValueKindSet }
```

Replace prior JSON-centric custom payload fields with typed/binary config transport at runtime boundary.

### 2) Error taxonomy (`crates/orchestrator-core/src/block/mod.rs`)

```rust
pub enum BlockError {
    Input(BlockInputError),
    Validation(BlockValidationError),
    Runtime(BlockRuntimeError),
}
```

Each typed error includes stable code + message (+ relevant IDs in context/logging).

### 3) SDK author surface (`crates/orchestrator-plugin-sdk/src/lib.rs`)

Keep `#[derive(Block)]` and require both methods:

```rust
impl MyBlock {
    pub fn validate(&self, input: &BlockValue, ctx: &BlockValidateContext) -> Result<(), BlockError> { ... }
    pub fn run(&self, input: BlockValue, ctx: &BlockContext) -> Result<BlockRunResult, BlockError> { ... } // sync or async
}
```

Generated by derive:

1. registration glue
2. descriptor metadata
3. config decode/encode glue
4. compile-time signature checks for required methods
5. constructors:
   - `into_block_config(self)`
   - `into_block(self)` (via extension layer where user-facing `Block` type lives)

### 4) Workflow composition API (`crates/orchestrator-core/src/workflow.rs`, `crates/orchestrator-blocks/src/block.rs`)

Primary user API:

1. `Workflow::new()`
2. `workflow.link(&from, &to)`
3. `workflow.on_error(&from, &handler)`
4. `workflow.run()` / `workflow.run_async()`

Behavior:

1. `link` auto-registers unseen blocks.
2. `link` auto-records source binding for target input (deduped).
3. first `link` source becomes entry automatically.
4. `run` auto-validates before any execution.

`wf.add` is not used in documentation or promoted user path.

### 5) Standalone mapping block (`crates/orchestrator-blocks/src/block.rs`)

Add:

```rust
Block::map_input(|v: BlockValue| -> Result<BlockValue, BlockError> { ... })
```

This block is inserted explicitly in graph flows, instead of hidden per-block mapper hooks.

### 6) Plugin ABI (`crates/orchestrator-plugin-abi`, `crates/orchestrator-core/src/plugin/mod.rs`)

Move to ABI v2 binary manifest/register transport and keep strict validation + skip-failed behavior.

## Dataflow Semantics

1. One predecessor:
   - target receives predecessor value directly.
2. Multiple predecessors:
   - target receives `BlockValue::List` in deterministic link insertion order.
3. `map_input` block:
   - receives incoming value
   - returns transformed value
   - downstream block validates and runs against transformed value.

## Validation Contract

Validation runs during `run`/`run_async` before execution:

1. source existence for all implicit input bindings
2. source upstream reachability
3. duplicate source binding detection
4. mode/cardinality compatibility
5. kind compatibility (`BlockValueKindSet`)
6. plugin block availability and linkage checks

Failure aborts run before side effects.

## Author Experience Examples

### Example A: SendEmail block (required `validate` + `run`)

```rust
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, orchestrator_plugin_sdk::Block)]
#[block(
  type_id = "send_email",
  display_name = "Send Email",
  input(mode = "once", kinds = ["string", "map", "null"]),
  output(mode = "once", kinds = ["map"])
)]
pub struct SendEmail {
  pub to: Option<String>,
  pub subject: Option<String>,
}

impl SendEmail {
  pub fn validate(
    &self,
    input: &orchestrator_plugin_sdk::BlockValue,
    _ctx: &orchestrator_plugin_sdk::BlockValidateContext,
  ) -> Result<(), orchestrator_plugin_sdk::BlockError> {
    if !input.is_map() && !input.is_string() && !input.is_null() {
      return Err(orchestrator_plugin_sdk::BlockValidationError::new(
        "validation.unsupported_input",
        "send_email expects map|string|null"
      ).into());
    }
    Ok(())
  }

  pub fn run(
    &self,
    input: orchestrator_plugin_sdk::BlockValue,
    ctx: &orchestrator_plugin_sdk::BlockContext,
  ) -> Result<orchestrator_plugin_sdk::BlockRunResult, orchestrator_plugin_sdk::BlockError> {
    ctx.log_info("email.send.attempt", orchestrator_plugin_sdk::BlockValue::Null);
    let to = self.to.clone().unwrap_or_else(|| "user@example.com".to_string());
    let body = input.as_string().unwrap_or_default();
    Ok(orchestrator_plugin_sdk::BlockRunResult::Once(
      orchestrator_plugin_sdk::BlockValue::map([
        ("sent".into(), orchestrator_plugin_sdk::BlockValue::Bool(true)),
        ("to".into(), orchestrator_plugin_sdk::BlockValue::String(to)),
        ("body".into(), orchestrator_plugin_sdk::BlockValue::String(body)),
      ])
    ))
  }
}
```

### Example B: Block-only wiring (no `wf.add`)

```rust
let read = FileRead { path: Some("in.txt".into()) }.into_block();
let mapper = Block::map_input(|v| {
    let s = v.as_string().ok_or_else(|| BlockInputError::new("input.expected_string", "string required"))?;
    Ok(BlockValue::String(s.trim().to_string()))
});
let send = SendEmail { to: Some("user@example.com".into()), subject: Some("Welcome".into()) }.into_block();

let mut wf = Workflow::new();
wf.link(&read, &mapper);
wf.link(&mapper, &send);
wf.run()?; // auto validation first
```

### Example C: Auto entry + auto validation behavior

1. First `link` call sets entry to `from`.
2. `run()` automatically calls validation.
3. Validation failure prevents all side-effecting block `run` calls.

## Implementation Plan

### Phase A: Core value/error contracts

1. Add `BlockValue`, `BlockRunResult`, `BlockValueKind`, `BlockValueKindSet`.
2. Add typed `BlockError` taxonomy.
3. Remove JSON contract transport in core execution interfaces.

### Phase B: SDK derive enforcement

1. Extend derive macro to require `validate` and `run`.
2. Add compile tests for missing/invalid method signatures.
3. Keep sync+async `run` support via adapter, with one method name.

### Phase C: Workflow API behavior update

1. Shift to block-only composition APIs in docs and examples.
2. Implement link-implied input binding and auto-entry.
3. Ensure run always validates before execution.

### Phase D: `map_input` block primitive

1. Remove `input_from_map` API.
2. Add standalone `map_input` block constructor.
3. Execute mapper as normal block in runtime flow.

### Phase E: Built-ins and plugin boundary

1. Migrate built-ins to new `BlockValue` IO model.
2. Implement ABI v2 binary plugin exchange.
3. Keep built-ins as plugin pack and plugin-only execution path.

### Phase F: Documentation and templates

1. Update `docs/block-sdk-template.md`.
2. Update `README.md`.
3. Update scaffold template script for required `validate` + `run`.

## Test Plan

### Compile-time tests

1. Derive fails if `validate` missing.
2. Derive fails if `run` missing.
3. Derive fails on invalid signatures.

### Unit tests

1. `BlockValue` helpers and deterministic map behavior.
2. `BlockValueKindSet` intersections and compatibility.
3. Error taxonomy and codes.
4. `map_input` transform behavior.

### Integration tests

1. Block-only composition works without `wf.add`.
2. `link` auto-binds input sources and dedupes duplicates.
3. first `link` auto-sets entry.
4. `run` auto-validates and prevents side effects on validation failure.
5. built-in plugin pack loads and runs from `./blocks` path.

### Regression tests

1. retries/timeouts/on_error still work.
2. plugin skip-failed behavior unchanged.
3. deterministic output ordering retained.

## Risks and Mitigations

1. Risk: API migration churn for existing usage.
   - Mitigation: provide migration doc and focused compile-time diagnostics.
2. Risk: closure-backed `map_input` complicates persistence/export.
   - Mitigation: keep explicitly in-memory for this slice; persistence out of scope.
3. Risk: binary ABI migration defects.
   - Mitigation: compatibility tests + strict loader validation.

## Acceptance Criteria

1. Block authors write only config + `validate` + `run`.
2. User workflow examples no longer rely on `wf.add`.
3. `map_input` standalone block works as intended in normal pipelines.
4. `run` always validates first.
5. Built-ins remain plugin-backed and examples run via plugin loading.

## Assumptions

1. v4 line remains breaking.
2. persistence/export for closure blocks is intentionally deferred.
3. typed Rust known-block composition remains primary authoring mode for this slice.
